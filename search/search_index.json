{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to eNSPanel","text":"<p>For full documentation visit here. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>LD2410 presence sensor</li> <li>Low cost PCB production (dimensions &lt;100x100mm)</li> <li>Microphone for voice assistant</li> <li>mother-daughter pcb (to extend functionalities)</li> <li>enclosure compatibility <code>*</code></li> <li>all the goodies from the NSPanel such as:</li> <li>capacitive display</li> <li>buzzer </li> <li>2 relays</li> <li>...</li> </ul> <p><code>*</code> only if not slotting the LD2410. otherwise a 3d printed part is required.</p>"},{"location":"#why","title":"Why?","text":"<p>The NSPanel from SonOff is a great device. I have 8 in my home serving as thermostats and doing much more. Unfortunately their outdated hardware is quite limiting. </p> <p>For example one of the reason why the ESPHome version struggles in uploading the TFT to the Nextion panel is the lack of free memory.</p> <p>Another reason why the NSPanel needed an upgrade was/is the lack of other functionalities. With edge AI and wake-word recognition inside the ESP32-S3 module you could really have a smart voice assistant in each room (like I have in my case).</p> <p>Initially I also wanted to slot a ZigBee module that could also enhance my home ZigBee network but starting from v1.4 I decided that mother-daughter approach was the best to minimize costs and reduce waste.</p> <p>For example one could design a daughter board with a small speaker to engage with the voice assistant... Want an atmospheric sensor? design a board for it. Not happy with the AI capabilities of the slotted ESP32-S3? you get the idea :)</p>"},{"location":"#how","title":"How?","text":"<p>Since the replacement board needed to be compatible with the original board, a 1:1 SVG has been created with relevant holes and dimentions.  </p> <p></p>"},{"location":"changelog/","title":"Change Log","text":"<p>During the development and prototyping phase I designed different versions of the PCB.</p> <p>This page is meant to be a changelog of the different versions of the PCB.</p> <p>The current version is v2.1.4 which is the one supporting the daughter board. Here below a picture of the v2.1.4 PCB:</p> <p></p>"},{"location":"configuration/","title":"Configuration","text":"<p>ESPHome configuration can be found in the <code>esphome</code> folder inside the repository. </p> <p>Also minimal configuration for specific modules can be found in the respective module pages. For example, the microphone and the presence sensor have their own configuration snippets.</p>"},{"location":"configuration/#vekexasia-hmiyaml","title":"vekexasia-hmi.yaml","text":"<p>You can check the <code>vekexasia-hmi.yaml</code> file for a way to use the other modules yaml files.</p> <p>Keep in mind that the <code>vekexasia-hmi.yaml</code> file is a way to combine all the modules into one yaml file. It is not a requirement to use it.</p> <p>Also, this configuration might not work out of the box as it might be missing some other configuration elements that I regularly use.</p>"},{"location":"daughter/","title":"Daughter Boards","text":"<p>The first big noticeable difference between the original PCB and the new one is the presence of a daughter board. The idea behind this is to have a main PCB that can be used for different purposes. For example, you could design a daughter board with a ZigBee module, or a daughter board with a speaker, or a daughter board with a sensor. The possibilities are endless.</p> <p>The main PCB has 6 GPIOs that can be used to communicate with the daughter board. The daughter board can be powered by the main PCB... Both +5V and +3.3V are available on the daughter board.</p> <p>Daughter/mother connection can be done via the BC075-10-A-L-A connector (if soldered) or wires could be hand-soldered to the 1mm pitch pads on the main PCB.</p> <p>For example, you could design a daughter board with a ZigBee module, or a daughter board with a speaker, or a daughter board with a sensor. The possibilities are endless.</p> <p>The main PCB has 6 GPIOs that can be used to communicate with the daughter board. </p>"},{"location":"daughter/#connector","title":"Connector","text":"<p>Daughter/mother connection can be done via the BC075-10-A-L-A connector (if soldered) or wires could be hand-soldered to the 1mm pitch pads on the main PCB.</p> <p></p> <p>From left to right here the 10 pins:</p> <ol> <li>+5V</li> <li>GND</li> <li>IO14</li> <li>IO21</li> <li>IO47</li> <li>IO48</li> <li>IO8</li> <li>IO16</li> <li>GND</li> <li>3.3V</li> </ol>"},{"location":"daughter/#designing-a-daughter-board","title":"Designing a Daughter Board","text":"<p>The daughter board can be designed in any way you like. But there are dimension constraints.</p> <p>Constraints:</p> <ul> <li>max 34.6x51.4mm</li> <li>max 1.6mm thickness</li> <li>1mm pitch for the connector</li> <li>at least 16.51 mm clearance from first connector pad to the edge of the board</li> <li>at least 8.5 mm clearance from the last connector pad to the edge of the board</li> </ul> <p>All measurements are shown below: </p> <p>NOTE: Please mind the hole in the daughter board. The hole is there to allow the daughter board to be slotted in the enclosure. The hole is 2.1mm in radius and is centered at ~3.2mm from left edge and 11.6mm from the top edge.</p> <p>NOTE: Having some clearance is always a good idea.</p> <p>Also, in case you need to slot an antenna, please use the leftmost edge of the daughter board!</p>"},{"location":"flashing/","title":"Flashing","text":"<p>After slotting the ESP32 along with the first required components, you do not need to solder the header. Actually it's not a good idea also because the display will not fit anymore and desoldering it is a pain..</p> <p>I would recommend to either use some pogo pin clips like this one, or just press fit the pins keeping them in place.</p> <p>After the first flashing, the other components can be soldered in any order.</p>"},{"location":"flashing/#flashing-the-firmware","title":"Flashing the Firmware","text":"<p>Besides the hardware connection you need to either use the esphome cli or the web esphome flasher using a USB-TTL adapter.</p> <p>To enter bootloader mode you need to connect the <code>EN</code> and <code>IO0</code> pins to ground. Specifically I find that a good way to to it is following the sequence below:</p> <ul> <li>Connect your adapter to the header provided</li> <li>Connect the <code>EN</code> pin to ground</li> <li>Connect the <code>IO0</code> pin to ground</li> <li>Remove the <code>EN</code> pin from ground</li> <li>Remove the <code>IO0</code> pin from ground</li> </ul> <p>PROTIP: The ESP32 metal case is GND.</p>"},{"location":"flashing/#the-first-firmware","title":"The First Firmware","text":"<p>As per the first firmware the following should just work out of the box.</p> <pre><code>esphome:\n  name: sample-esp32\n  friendly_name: sample-esp32\n  platformio_options:\n    board_build.flash_mode: dio\nesp32:\n  board: esp32-s3-devkitc-1\n  framework:\n    type: esp-idf\n\npsram:\n  mode: octal\n  speed: 80MHz\n\n# Enable logging\nlogger:\n  hardware_uart: UART0\n  level: DEBUG\n\n# Enable Home Assistant API\napi:\n  # Once onboarded into HA u can remove this\n  reboot_timeout: 0s\n  encryption:\n    key: \"redacted\"\n\nota:\n  password: \"redacted\"\n\nwifi:\n  ssid: !secret wifi_ssid\n  password: !secret wifi_password\n  # had issues with output_power not being specified\n  output_power: 12dB\n</code></pre> <p>Flashing the previous bare minimum firmware should be straightforward. If you have any issues please refer to the ESPHome documentation.</p>"},{"location":"gpios/","title":"GPIOs","text":"<p>Here a GPIO table for the ESP32 module used in the PCB:</p> GPIO Function Description 3 Thermistor VCC Switch to provide NTC thermistor VCC only when measuring 4 Display Display power on/off 5 Display RX Display UART data line 6 Display TX Display UART data line 7 Buzzer Buzzer PWM 8 Daughter 9 Thermistor ADC Measurement PIN for the Thermistor 10 Header wired but not used 11 Relay Relay #1 12 Relay Relay #2 13 Header wired but not used 14 Daughter 15 Daughter 16 LD2410 Presence sensor power cutoff 17 LD2410 Presence sensor RX 18 LD2410 Presence sensor TX 35 Microphone i2c mic WS 36 Microphone i2c mic SD 37 Microphone i2c mic SCK 38 Microphone i2c mic SCK 41 Switch right switch 42 Switch left switch 21 Daughter 47 Daughter 48 Daughter <p>Basically all the useable GPIOs are being used. Some of them are being allocated for the daughter board. And 2 of them for the 2.0mm pitch header.</p> <p>Here below a pinout reference taken from <code>atomic14</code>'s repository</p> <p></p>"},{"location":"known-issues/","title":"Known Issues","text":""},{"location":"known-issues/#soldering","title":"Soldering","text":"<p>Most of the time soldering the right components properly is the key to a successful build. Check the soldering page for more info.</p> <p>Especially the microphone and the LD2410 might be tricky to solder.</p>"},{"location":"known-issues/#bootloop","title":"Bootloop","text":"<p>It happened to me that the ESP32 went into a bootloop after being flashed with a minimal firmware.</p> <p>I am not sure what caused it, but I suspect it was the <code>output_power</code> not being specified in the <code>wifi</code> section as adding it fixed the issue.</p>"},{"location":"known-issues/#microphone-not-recognizing-wake-word","title":"Microphone not recognizing wake word","text":"<p>If the microphone is not recognizing the wake word, it might be due to the microphone not being properly soldered.</p>"},{"location":"known-issues/#ld2410-not-working","title":"LD2410 not working","text":"<p>If the LD2410 is not working, it might be due soldering issue. Check the soldering and the connections. The presence sensor page shows a diagram of the connections.</p>"},{"location":"microwakeword/","title":"Voice Assistant","text":"<p>Since ESPHome supports on-device wake word detection, it is possible to use the wake word detection to trigger a voice assistant. This is a sample configuration that uses the wake word detection to trigger a voice assistant.</p> <p>Considering the chosen module (ESP32-S3-WROOM-1-N16R8) has PSRAM, the eNSPanel is fully capable to perform on-device wake word detection.</p> <p>After properly configuring the microphone, the following configuration can be used to trigger a voice assistant.</p> <pre><code>esphome:\n  on_boot:\n    priority: -100\n    then:\n      - micro_wake_word.start:\nexternal_components:\n  - source: github://pr#5230\n    components: esp_adf\n    refresh: 0s\nmicro_wake_word:\n  microphone: mic\n  model: hey_jarvis\n  on_wake_word_detected:\n    - rtttl.play: 'beep:d=16,o=5,b=100:e6'\n    - wait_until:\n        not:\n          rtttl.is_playing:\n    - voice_assistant.start:\nvoice_assistant:\n  on_client_connected:\n    - micro_wake_word.start:\n  on_client_disconnected:\n    - micro_wake_word.stop:\n  on_error:\n    then:\n      - rtttl.play: 'beep:d=16,o=5,b=100:e6'\n  on_end:\n    then:\n      - wait_until:\n          not:\n            voice_assistant.is_running:\n      - micro_wake_word.start:  \n</code></pre> <p>For debug purposes, once recognized, the buzzer will play a beep and the voice assistant will start. </p>"},{"location":"pcb/","title":"PCB","text":"<p>The PCB can be ordered at any pcb manifacturing website that supports the Gerber format. The Gerber files are in the <code>gerber</code> folder. Since v2.1 the PCB is &lt;100x100mm this will allow for a big discount when ordering.</p>"},{"location":"pcb/#how-to-order","title":"How to order?","text":"<p>Simply download the <code>gerber.zip</code> file from the <code>gerber</code> folder and upload it to your favorite PCB manifacturer.</p> <p>Another possibility would be using this PCBWay shared project. Be aware that the assembly and BOM in the project page has never been tested.</p>"},{"location":"pcb/#pcb-settings","title":"PCB Settings","text":"<p>Besides the standard settings, I'd recommend to use HASL lead-free.</p>"},{"location":"soldering/","title":"Soldering","text":"<p>First component that needs to be soldered is the ESP32. This makes the first flashing super easy.</p>"},{"location":"soldering/#1-esp32-soldering","title":"1) ESP32 Soldering","text":"<p>A bare minimal component soldering includes: - R9 (0603 10k\u03a9) - C6, C2, C4, C3 (0603 100nF) - C10, C12, C13 (0805 22uF) - LDO (U4)</p> <p>The components are circled here:</p> <p></p> <p>After soldering the ESP32, the LDO and the capacitors, the ESP32 can be flashed using the bottom right header. </p>"},{"location":"soldering/#2-other-modules","title":"2) Other modules","text":"<p>The other modules can be soldered in any order. Just make sure to follow the schematic and the BOM. I'd recommend to flash first the ESP32 and then solder the other components.</p> <p>Some modules might be tricky to solder. For example, the microphone and the LD2410 might require some patience.</p> <p>I'd solder the bottom layer components after first flashing the ESP32. This way you can test the ESP32 and the LDO. </p>"},{"location":"textupdateproto/","title":"Text Update Proto","text":""},{"location":"textupdateproto/#the-problem","title":"The problem","text":"<p>My specific setup is a Home Assistant integration with ESPHome.</p> <p>The Nextion firmware has more than 15 text elements that rely on home assistant for their content.</p> <p>The \"original\" way of updating the text elements is to use the <code>text_sensor</code> component in ESPHome and update the text elements in the Nextion firmware using the <code>on_value</code> trigger.</p> <p>But this approach requires a <code>text_sensor</code> per component hence the code becomes a mess really fast...</p> <p>The solution involves 2 parts:</p> <ul> <li>Home Assistant side: a text sensor that holds all the text elements in a single string</li> <li>ESPHome side: a script that parses the string and updates the text elements in the Nextion display</li> </ul> <p>It's important to note that this approach can be used standalone and there is nothing in this project that relies on this approach/protocol.</p> <p>I just found it useful for my specific use case. So documenting it here sounds like a good idea.</p>"},{"location":"textupdateproto/#the-protocol","title":"The protocol","text":"<p>To fix my issue I had to invent a text format that could be easily parsed by the ESPHome script(see below) and HomeAssistant printable.</p> <p>One caveat I found is that text sensor in Home Assistant does not support states longer than 255 characters. So I used an attribute instead.</p> <p>The text format is as follows:</p> <pre><code>$page.$componentName,$value|\n$page.$componentName,$value|\n|\n</code></pre> <ul> <li><code>$page</code>: is the page name in the Nextion display. If the page is the same for all the components you can omit it.</li> <li><code>$componentName</code>: is the component name in the Nextion display</li> <li><code>$value</code>: is the value to be set in the text component</li> </ul> <p>Between each component there is a <code>|\\n</code> separator. The end is marked by a <code>|</code> character.</p>"},{"location":"textupdateproto/#esphome-side","title":"EspHome side","text":"<pre><code>script:\n  - id: restore_nspanel_texts\n    then:\n      - lambda: |-\n          std::string main = id(nspanel_texts).state;   \n          std::string md = \"| \";   \n\n          size_t pos = 0;   \n          int index = 0;   \n          while ((pos = main.find(md)) != std::string::npos) {   \n            std::string s = main.substr(0, pos);   \n            main.erase(0, pos + md.length());  \n            std::string delimiter = \",\";   \n            std::string key = s.substr(0, s.find(delimiter));   \n            std::string value = s.substr(key.length() + 1, s.rfind(delimiter) - key.length()  - 1); \n            id(disp1).set_component_text_printf(key.c_str(), \"%s\", value.c_str());\n          }\n\ntext_sensor:\n  - platform: homeassistant\n    id: nspanel_texts\n    entity_id: sensor.nspanel_texts\n    attribute: value\n    on_value:\n      then:\n        - script.execute: restore_nspanel_texts\n</code></pre>"},{"location":"textupdateproto/#home-assistant-side","title":"Home Assistant side","text":"<p>Home assistant side obviously depends on your personal setup both in HA and Nextion.</p> <p>Anyways here is a simple example of how to create such sensor.</p> <pre><code>template:\n  - sensor:\n    - name: \"NSPanel Texts\"\n      state: &gt;-\n        {{ now().strftime('%d-%m-%Y %H:%M:%S') }}\n      attributes:\n        value: &gt;-\n          weather_now.temp_out,{{states('sensor.nspanel_outside_temp')}}|\n          weather_now.humidity_out,{{states('sensor.nspanel_outside_humidity')}}|\n          weather_now.wind_speed,{{states('sensor.nspanel_outside_windspeed')}}|\n          weather_now.sunset,{{states('sensor.nspanel_next_sunset')}}|\n          weather_now.sunrise,{{states('sensor.nspanel_next_sunrise')}}|\n          |\n</code></pre> <p>This is a simple example of how to update the weather information in the Nextion display updating the <code>weather_now</code> page components.</p>"},{"location":"textupdateproto/#caveats","title":"Caveats","text":"<p>As already said a Home Assistant attribute must be used because the state is limited to 255 characters. Also, keep in mind that nextion components should be marked as <code>global</code>.</p>"},{"location":"modules/buttons/","title":"Physical Buttons","text":"<p>Much like the original PCB, eNSPanel is slotting 2 microswitches to make a use of the 2 physical buttons.</p>"},{"location":"modules/buttons/#gpio","title":"GPIO","text":"<p>The 2 microswitches are connected to the ESP32 via <code>IO42</code>(left) and <code>IO41</code>(right).</p>"},{"location":"modules/buttons/#configuration","title":"Configuration","text":"<p>The most up-to-date configuration is in the <code>esphome</code> folder. This is a known to be working minimal configuration for the thermistor:</p> <pre><code>binary_sensor:\n  # Left button below the display\n  - platform: gpio\n    name: $friendly_devicename Left Button\n    pin:\n      number: GPIO42\n      inverted: true\n    id: left_button\n\n  # Right button below the display\n  - platform: gpio\n    name: $friendly_devicename Right Button\n    pin:\n      number: GPIO41\n      inverted: true\n    id: right_button\n</code></pre>"},{"location":"modules/buzzer/","title":"Buzzer","text":"<p>Both the original PCB and all the eNSPanel PCBs slot a buzzer.</p> <p>The buzzer could be used as a feedback after user's action or to play tones/notify important messages.</p>"},{"location":"modules/buzzer/#gpio","title":"GPIO","text":"<p>The buzzer is connected to the ESP32 via GPIO7</p>"},{"location":"modules/buzzer/#configuration","title":"Configuration","text":"<p>Always refer to the <code>esphome</code> folder for the most up to date working configuration. This is a known to be working minimal configuration for the buzzer</p> <pre><code>rtttl:\n  id: buzzer\n  output: buzzer_out\n\noutput:\n  - platform: ledc\n    id: buzzer_out\n    pin:\n      number: 7\n</code></pre>"},{"location":"modules/buzzer/#part","title":"Part","text":"<p>Almost any <code>SMD,7.5x7.5mm</code> buzzer with an operating voltage of 3v3 should be working. For my boards I went with <code>MLT-7525</code></p>"},{"location":"modules/buzzer/#soldering","title":"Soldering","text":"<p>Soldering the buzzer and the related parts (see below) should be pretty straightforward. Just mind both the buzzer and the diode polarity.</p>"},{"location":"modules/buzzer/#related-parts","title":"Related Parts","text":"<p>All the parts related to the buzzer are containerd inside the silkscreen polygon marked as <code>BUZZER</code>.</p> <p></p> <p>Wish you to not slot the buzzer for whatever reason you can skip soldering all the components included in that region.</p>"},{"location":"modules/display/","title":"Display","text":"<p>The capacitive Nextion display is what makes the NSPanel a good Home automation product.</p>"},{"location":"modules/display/#gpio","title":"GPIO","text":"<p>In the original board the nextion display communicates with the esp32 via <code>IO16</code> &amp; <code>IO17</code>. In the new board the display communicates with the esp32 via <code>IO5</code> &amp; <code>IO6</code>, they are not hardware UART but that was already allocated to the presence sensor which has a higher baudrate.</p>"},{"location":"modules/display/#configuration","title":"Configuration","text":"<p>Always refer to the <code>esphome</code> folder for the most up to date working configuration. This is a known to be working minimal configuration for the display</p> <pre><code>uart:\n  - tx_pin: 5\n    rx_pin: 6\n    baud_rate: 115200\n    rx_buffer_size: 4096\n    id: tf_uart\n\ndisplay:\n  - platform: nextion\n    id: disp1\n    uart_id: tf_uart\n    tft_url: $tft_url\n\nswitch:\n  - platform: gpio\n    name: Screen Power\n    id: screen_power\n    entity_category: config\n    pin:\n      number: 4\n      inverted: true\n    restore_mode: ALWAYS_OFF\n</code></pre> <p>Please note that the <code>tft_url</code> should be the path to the compiled tft file. The <code>tft</code> file is the compiled version of the <code>HMI</code> file that is generated by the Nextion Editor.</p> <p>Also note that there are other configuration elements that make the display work as expected. Please refer to the <code>esphome</code> folder for the most up to date configuration.</p>"},{"location":"modules/display/#part","title":"Part","text":"<p>There are several parts that are required for the display to work. The parts are all contained in the <code>DISPLAY</code> silkscreen polygon.</p>"},{"location":"modules/display/#display-firmware","title":"Display Firmware","text":"<p>The nextion display can be updated via the <code>UART</code> interface. The display firmware is included in this repository. With the original NSPanel hardware, uploading a new <code>tft</code> file to the display was a pain. With the new board, thanks to the more generous availability of memory, uploading a new <code>tft</code> file is a breeze.</p> <p>The firmware for the display is included in this repository and can be found in the <code>nextion</code> folder. Wish you modify the display firmware, you can use the Nextion Editor generate the <code>HMI</code> file (or modify the provided one) and then compile it to a <code>tft</code> file.</p>"},{"location":"modules/display/#getting-ready-to-flash-the-display-firmware","title":"Getting ready to flash the display firmware","text":"<p>To flash the display firmware you need to have the following:</p> <ul> <li>a working <code>http</code> server that can serve the <code>tft</code> file</li> <li>a working <code>esphome</code> firmware that can communicate with the display</li> <li>a HomeAssistant service that can trigger the display firmware update</li> </ul>"},{"location":"modules/display/#1-the-webserver","title":"1) The webserver","text":"<p>as of the http server I suggest you to spin up a simple <code>nginx</code> server that serves the <code>tft</code> file. </p> <p>The following Nginx configuration should work:</p> <p><pre><code>server {\n    listen 80;\n    root /var/www/html;\n}\n</code></pre> Just place the tft file in the <code>/var/www/html</code> folder and you should be good to go.</p> <p>Also, using something like filebrowser should make the process easier to manage firmware files.</p>"},{"location":"modules/display/#2-the-esphome-firmware","title":"2) The <code>esphome</code> firmware","text":"<p>The esphome configuration is provided in the <code>esphome/nextion.yaml</code> file. </p> <p>To summarize you need to have at least the <code>uart</code>, the <code>display</code> and the <code>api</code> component for the next step</p>"},{"location":"modules/display/#3-the-homeassistant-service","title":"3) The HomeAssistant service","text":"<p>The HomeAssistant service is provided in the <code>esphome/nextion.yaml</code> file.</p> <p>But you can also use the following service:</p> <pre><code>api:\n  services:\n    - service: upload_tft\n      then:\n        - lambda: 'id(disp1)-&gt;upload_tft();'\n</code></pre> <p>The $tft_url should be provided as part of the yaml esphome configuration. (check <code>esphome/vekexasia-hmi.yaml</code> for an example)</p>"},{"location":"modules/microphone/","title":"Microphone","text":"<p>The microphone is one of the new features included in the eNSPanel PCB. </p> <p>I decided to slot a microphone cause I wanted to have a device in each room capable of recognizing a wake word.</p>"},{"location":"modules/microphone/#gpio","title":"GPIO","text":"<p>The microphone needs to be a footprint compatible (see part below) i2c microphone. the following ESP32 pins were used:</p> <ul> <li>GPIO38 - lrclk</li> <li>GPIO40 - bclk</li> <li>GPIO39 - din</li> </ul>"},{"location":"modules/microphone/#configuration","title":"Configuration","text":"<p>Always refer to the <code>esphome</code> folder for the most up to date working configuration. This is a known to be working minimal configuration for the microphone</p> <pre><code>i2s_audio:\n  i2s_lrclk_pin: GPIO38\n  i2s_bclk_pin: GPIO40\nmicrophone:\n  - platform: i2s_audio\n    id: mic\n    adc_type: external\n    i2s_din_pin: GPIO39\n    pdm: false\n    channel: left\nvoice_assistant:\n  microphone: mic\n  auto_gain: 31dBFS\n#  noise_suppression_level: 2\n</code></pre>"},{"location":"modules/microphone/#part","title":"Part","text":"<p><code>ICS-43434</code> microphone was used and known to be working with the PCB.</p>"},{"location":"modules/microphone/#soldering","title":"Soldering","text":"<p>Soldering such mics require some patience. A good solder paste does wonders.</p> <p>What I usually do is:</p> <ul> <li>Solder all the components and keep the mic as last </li> <li>Apply solder paste (Better with a stencil)</li> <li>use hot air gun</li> <li>gently apply some force on top,</li> <li>test...</li> </ul> <p>In case it does not work I desolder with the hot air gun and repeat.</p>"},{"location":"modules/microphone/#related-parts","title":"Related Parts","text":"<p>Only C5 (top layer) and R3 (bottom layer) are needed to make the microphone to work. </p>"},{"location":"modules/microphone/#testing-the-mic","title":"Testing the mic","text":"<p>Sometimes it might be a pain to test a working microphone. To date I don't know any method more effective than installing the voice assist package and try to speak the wake word.</p> <p>Aka. You should really check out the voice assistant section of this documentation</p>"},{"location":"modules/microphone/#debugging-poor-audio-quality","title":"Debugging poor audio quality","text":"<p>Most of the times if u hear statics or other jibberish it means the microphone is not properly soldered onto the board.</p>"},{"location":"modules/presence/","title":"Presence Sensor","text":"<p>The LD2410 is a very well known and relatively inexpensive presence sensor.</p> <p>Its speed, angle and capabilities make it a very versatile sensor. The main drawback is that it cannot be battery powered.</p> <p>Thankfully we can power it via the main PCB. The sensor can be soldered on the main PCB. </p>"},{"location":"modules/presence/#gpios","title":"GPIOs","text":"<p>The LD2410 is wired to the ESP32 using GPIO17(RX) and GPIO18(TX). Furthermore, GPIO16 can be used to cut power to the module.</p>"},{"location":"modules/presence/#configuration","title":"Configuration","text":"<p>The most recent configuration yaml can be found in the <code>esphome</code> folder inside the repository. A known working configuration is the following:</p> <pre><code># Configuration for LD2410 presence sencor.\n# The sensor needs to be actively powered on to work. that is why GPIO16 is used for.\nswitch:\n  - platform: gpio\n    name: LD2410 Power\n    id: ld2410_power\n    pin:\n      number: 16\n      inverted: false\n    restore_mode: ALWAYS_OFF\n\nuart:\n  - tx_pin: 17\n    rx_pin: 18\n    baud_rate: 256000\n    parity: NONE\n    stop_bits: 1\n    id: ld2410_uart\n\nld2410:\n  uart_id: ld2410_uart\n\nbinary_sensor:\n  - platform: ld2410\n    has_target:\n      name: Presence\n    has_moving_target:\n      name: Moving Target\n    has_still_target:\n      name: Still Target\n\nsensor:\n  - platform: ld2410\n    moving_distance:\n      name : Moving Distance\n    still_distance:\n      name: Still Distance\n    moving_energy:\n      name: Move Energy\n    still_energy:\n      name: Still Energy\n    detection_distance:\n      name: Detection Distance\n</code></pre>"},{"location":"modules/presence/#drawbacks-of-slotting-the-ld2410","title":"Drawbacks of slotting the LD2410","text":"<p>Unfortunately due to the size of the sensor and its high frequency of operation, the sensor could not be placed in a more convenient location.</p> <p>Furthermore, due to height limitations in the current enclosure, you will need to print a 3d part to replace the original one.</p> <p>The 3D part can be found in the <code>3d</code> folder. This is the only replacement part needed to slot the LD2410 sensor.</p>"},{"location":"modules/presence/#ld2410-sensor-soldering","title":"LD2410 sensor soldering","text":"<p>Several iterations of the PCB were done to try to slot the LD2410 sensor without the need to change anything about the enclosure. Unfortunately, the sensor is too big to fit in the enclosure.</p> <p>The best compromise was to have the sensor laying on top of the PCB. This way there is a semi-easy way to solder the LD2410 sensor.</p> <p>To do that:</p> <ol> <li>place the sensor on the PCB.</li> <li>fill the pins with solder paste,</li> <li>use your hot air gun.</li> </ol>"},{"location":"modules/presence/#testing-with-a-multimeter","title":"Testing with a multimeter","text":"<p>After soldering the sensor, it's a good idea to test it with a multimeter.</p> <p>Testing continuity between the pins should give you a good idea if the sensor is soldered correctly. Just check out the following image. </p> <p>If you don't find continuity across the marked locations, then the sensor is not soldered correctly.</p>"},{"location":"modules/presence/#accuracy-behind-the-enclosure","title":"Accuracy behind the enclosure","text":"<p>The sensor is very accurate and can detect presence from a good distance. For sure there is a tradeoff when using the sensor behind a plastic enclosure. The sensor is not as accurate as it would be if it was placed in an open space. But in my non scientific tests, the sensor does still serve its purpose.</p>"},{"location":"modules/relays/","title":"Relays","text":"<p>Much like the original PCB, eNSPanel supports the original 2 Relays.</p> <p>Furthermore, even if there is no use for them right now, there are 2 other GPIO pins that can be used in the future in case there will ever a need for a new pcb for the power supply module.</p>"},{"location":"modules/relays/#gpio","title":"GPIO","text":"<p>The 2 relays are connected to the ESP32 via <code>IO11</code> and <code>IO12</code>.</p>"},{"location":"modules/relays/#configuration","title":"Configuration","text":"<p>The most up-to-date configuration is in the <code>esphome</code> folder. This is a known to be working minimal configuration for the 2 relays:</p> <pre><code>switch:\n  # Physical relay 1\n  - platform: gpio\n    name: Relay 1\n    id: relay_1\n    pin:\n      number: 11\n  # Physical relay 2\n  - platform: gpio\n    name: Relay 2\n    id: relay_2\n    pin:\n      number: 12\n</code></pre>"},{"location":"modules/relays/#climate-configuration","title":"Climate configuration","text":"<p>As explained in the thermistor documentation, the ESPHome platform provides a climate component that can be used to control a heater or a cooler. The climate component can be used to control a relay that turns on a heater or a cooler. </p> <p>The following is a sample configuration to leverage one of the relay to control a heater:</p> <pre><code>climate:\n  - platform: thermostat\n    id: termostato\n    name: \"Termostat\"\n    sensor: temperature\n    min_heating_off_time: 60s\n    min_heating_run_time: 60s\n    min_idle_time: 30s\n    heat_action:\n      - switch.turn_on: relay_1\n    idle_action:\n      - switch.turn_off: relay_1\n    default_preset: Home\n    preset:\n      - name: Home\n        default_target_temperature_low: $target_temp_home\n        mode: HEAT\n      - name: Comfort\n        default_target_temperature_low: $target_temp_comfort\n        mode: HEAT\n</code></pre>"},{"location":"modules/thermistor/","title":"Thermistor","text":"<p>Much like the original PCB, eNSPanel uses an NTC thermistor to measure ambient temperature.</p> <p>The thermistor is connected to the ESP32 via a voltage divider. The voltage divider is made up of a 20k resistor and the thermistor. The voltage divider is connected to the ESP32's ADC pin.</p> <p>The thermistor is a normal 10k NTC thermistor with a B value of 3950. There is another 10k resistor in series with the thermistor to protect the ESP32's ADC pin.</p>"},{"location":"modules/thermistor/#gpio","title":"GPIO","text":"<p>The thermistor is connected to the ESP32 via <code>IO9</code> which is ADC1 in the selected ESP32 module.</p>"},{"location":"modules/thermistor/#configuration","title":"Configuration","text":"<p>The most up-to-date configuration is in the <code>esphome</code> folder. This is a known to be working minimal configuration for the thermistor:</p> <pre><code>sensor:\n  # Internal temperature sensor, adc value\n  - platform: adc\n    id: ntc_source\n    pin: 9\n    attenuation: auto\n\n  # Internal temperature sensor, adc reading converted to resistance (calculation)\n  - platform: resistance\n    id: resistance_sensor\n    sensor: ntc_source\n    configuration: UPSTREAM\n    resistor: 10kOhm\n\n  # Internal temperature sensor, resistance to temperature (calculation)\n  - platform: ntc\n    id: temperature\n    sensor: resistance_sensor\n    calibration:\n      b_constant: 3950\n      reference_temperature: 25\u00b0C\n      reference_resistance: 10kOhm\n    name: Temperature\n\nswitch:\n  - platform: gpio\n    pin: 3\n    id: ntc_vcc\ninterval:\n  - interval: 10s\n    then:\n      - switch.turn_on: ntc_vcc\n      - delay: 100ms\n      - component.update: ntc_source\n      - switch.turn_off: ntc_vcc\n</code></pre> <p>Also the ESPHome platform provides a climate component that can be used to control a heater or a cooler. The climate component can be used to control a relay that turns on a heater or a cooler. Check the relays documentation for more info.</p>"}]}